% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nmfClustering.R
\name{nmfClustering}
\alias{nmfClustering}
\title{Robust Clustering via NMF (non-negative matrix factorization)}
\usage{
nmfClustering(
  mat,
  ranks = 10,
  nrun.per.rank = 30,
  min.coph = 0.95,
  nmf.method = "brunet",
  ncores = 1,
  plot = FALSE,
  seed = 2024,
  ...
)
}
\arguments{
\item{mat}{Numeric matrix (feature by sample) for clustering analysis.}

\item{ranks}{Numeric vector specifying the number of clusters to evaluate.}

\item{nrun.per.rank}{Integer specifying the number of runs per rank for clustering.}

\item{min.coph}{Numeric specifying the minimum cophenetic coefficient required for a rank to be optimal.}

\item{nmf.method}{Character string specifying the method for NMF analysis.}

\item{ncores}{Integer specifying the number of CPU cores to use for parallel processing.}

\item{plot}{Logical indicating whether to plot the results.}

\item{seed}{An integer used to seed the random number generator for NMF analysis.}

\item{...}{Additional arguments to be passed to the nmf function.}
}
\value{
An NMFfitX1 object when only one rank is provided. A list containing
the optimal number of communities (bestK), a list of NMFfitX1 objects (NMFfits), and a ggplot
object (p) displaying the cophenetic coefficient across different values of K.
}
\description{
When one rank is provided, NMF clustering will be performed. When multiple ranks
are provided, this function will determine the optimal number of communities (K)
by assessing the cophenetic coefficient across different values of K.
}
\examples{
library(NMF)
library(SpatialEcoTyper)
mat <- matrix(rnorm(1000, 3), 20)
mat[mat<0] = 0

## Specify one rank
result <- nmfClustering(mat = mat, ranks = 3, nrun.per.rank = 3)
predict(result)

## Determine optimal ranks by testing multiple ranks
result <- nmfClustering(mat = mat, ranks = 2:5, nrun.per.rank = 3)
result$p
result$bestK
predict(result$NMFfits[[paste0("K.", result$bestK)]])

}
